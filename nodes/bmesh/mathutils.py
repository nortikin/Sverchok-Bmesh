import bpy,bmesh,mathutils
from bpy.props import EnumProperty, FloatProperty
from sverchok.node_tree import SverchCustomTreeNode
from sverchok.data_structure import (updateNode, enum_item as e, second_as_first_cycle as safc,match_long_repeat)

dict_mathutils = {"Color": ["This object gives access to Colors in Blender.\nMost colors returned by Blender APIs are in scene linear color space, as defined by the OpenColorIO configuration. The notable exception is user interface theming colors, which are in sRGB color space.\n", {"Color()": ["This object gives access to Colors in Blender.\nMost colors returned by Blender APIs are in scene linear color space, as defined by the OpenColorIO configuration. The notable exception is user interface theming colors, which are in sRGB color space.\n", ["rgb"], ["rgb (3d vector) \u2013 (r, g, b) color values\n"], "None"], "copy()": ["Returns a copy of this color.\n", [], [], "Returns\nA copy of the color.\nReturn type\nColor\nNote\nuse this to get a copy of a wrapped color with no reference to the original data.\n"], "freeze()": ["Make this object immutable.\nAfter this the object can be hashed, used in dictionaries & sets.\n", [], [], "Returns\nAn instance of this object.\n"], "from_aces_to_scene_linear()": ["Convert from ACES2065-1 linear to scene linear color space.\n", [], [], "Returns\nA color in scene linear color space.\nReturn type\nColor\n"], "from_rec709_linear_to_scene_linear()": ["Convert from Rec.709 linear color space to scene linear color space.\n", [], [], "Returns\nA color in scene linear color space.\nReturn type\nColor\n"], "from_scene_linear_to_aces()": ["Convert from scene linear to ACES2065-1 linear color space.\n", [], [], "Returns\nA color in ACES2065-1 linear color space.\nReturn type\nColor\n"], "from_scene_linear_to_rec709_linear()": ["Convert from scene linear to Rec.709 linear color space.\n", [], [], "Returns\nA color in Rec.709 linear color space.\nReturn type\nColor\n"], "from_scene_linear_to_srgb()": ["Convert from scene linear to sRGB color space.\n", [], [], "Returns\nA color in sRGB color space.\nReturn type\nColor\n"], "from_scene_linear_to_xyz_d65()": ["Convert from scene linear to CIE XYZ (Illuminant D65) color space.\n", [], [], "Returns\nA color in XYZ color space.\nReturn type\nColor\n"], "from_srgb_to_scene_linear()": ["Convert from sRGB to scene linear color space.\n", [], [], "Returns\nA color in scene linear color space.\nReturn type\nColor\n"], "from_xyz_d65_to_scene_linear()": ["Convert from CIE XYZ (Illuminant D65) to scene linear color space.\n", [], [], "Returns\nA color in scene linear color space.\nReturn type\nColor\n"], "b": ["Blue color channel.\n", [], [], "Type\nfloat\n"], "g": ["Green color channel.\n", [], [], "Type\nfloat\n"], "h": ["HSV Hue component in [0, 1].\n", [], [], "Type\nfloat\n"], "hsv": ["HSV Values in [0, 1].\n", [], [], "Type\nfloat triplet\n"], "is_frozen": ["True when this object has been frozen (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when the owner of this data is valid.\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this object wraps external data (read-only).\n", [], [], "Type\nboolean\n"], "owner": ["The item this is wrapping or None (read-only).\n", [], [], "owner\uf0c1\nThe item this is wrapping or None (read-only).\n"], "r": ["Red color channel.\n", [], [], "Type\nfloat\n"], "s": ["HSV Saturation component in [0, 1].\n", [], [], "Type\nfloat\n"], "v": ["HSV Value component in [0, 1].\n", [], [], "Type\nfloat\n"]}], "Euler": ["This object gives access to Eulers in Blender.\nSee also\nEuler angles on Wikipedia.\n", {"Euler()": ["This object gives access to Eulers in Blender.\nSee also\nEuler angles on Wikipedia.\n", ["angles", "order"], ["angles (3d vector) \u2013 Three angles, in radians.\n", "order (str) \u2013 Optional order of the angles, a permutation of XYZ.\n"], "None"], "copy()": ["Returns a copy of this euler.\n", [], [], "Returns\nA copy of the euler.\nReturn type\nEuler\nNote\nuse this to get a copy of a wrapped euler with no reference to the original data.\n"], "freeze()": ["Make this object immutable.\nAfter this the object can be hashed, used in dictionaries & sets.\n", [], [], "Returns\nAn instance of this object.\n"], "make_compatible()": ["Make this euler compatible with another, so interpolating between them works as intended.\nNote\nthe rotation order is not taken into account for this function.\n", ["other"], [], "None"], "rotate()": ["Rotates the euler by another mathutils value.\n", ["other"], ["other (Euler, Quaternion or Matrix) \u2013 rotation component of mathutils value\n"], "None"], "rotate_axis()": ["Rotates the euler a certain amount and returning a unique euler rotation (no 720 degree pitches).\n", ["axis", "angle"], ["axis (string) \u2013 single character in [\u2018X, \u2018Y\u2019, \u2018Z\u2019].\n", "angle (float) \u2013 angle in radians.\n"], "None"], "to_matrix()": ["Return a matrix representation of the euler.\n", [], [], "Returns\nA 3x3 rotation matrix representation of the euler.\nReturn type\nMatrix\n"], "to_quaternion()": ["Return a quaternion representation of the euler.\n", [], [], "Returns\nQuaternion representation of the euler.\nReturn type\nQuaternion\n"], "zero()": ["Set all values to zero.\n", [], [], "None"], "is_frozen": ["True when this object has been frozen (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when the owner of this data is valid.\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this object wraps external data (read-only).\n", [], [], "Type\nboolean\n"], "order": ["Euler rotation order.\n", [], [], "Type\nstring in [\u2018XYZ\u2019, \u2018XZY\u2019, \u2018YXZ\u2019, \u2018YZX\u2019, \u2018ZXY\u2019, \u2018ZYX\u2019]\n"], "owner": ["The item this is wrapping or None (read-only).\n", [], [], "owner\uf0c1\nThe item this is wrapping or None (read-only).\n"], "x": ["Euler axis angle in radians.\n", [], [], "Type\nfloat\n"], "y": ["Euler axis angle in radians.\n", [], [], "Type\nfloat\n"], "z": ["Euler axis angle in radians.\n", [], [], "Type\nfloat\n"]}], "Matrix": ["This object gives access to Matrices in Blender, supporting square and rectangular matrices from 2x2 up to 4x4.\n", {"Matrix()": ["This object gives access to Matrices in Blender, supporting square and rectangular matrices from 2x2 up to 4x4.\n", ["[rows]"], ["None"], "None"], "Diagonal()": ["Create a diagonal (scaling) matrix using the values from the vector.\n", ["vector"], ["vector (Vector) \u2013 The vector of values for the diagonal.\n"], "Returns\nA diagonal matrix.\nReturn type\nMatrix\n"], "Identity()": ["Create an identity matrix.\n", ["size"], ["size (int) \u2013 The size of the identity matrix to construct [2, 4].\n"], "Returns\nA new identity matrix.\nReturn type\nMatrix\n"], "LocRotScale()": ["Create a matrix combining translation, rotation and scale, acting as the inverse of the decompose() method.\nAny of the inputs may be replaced with None if not needed.\n", ["location", "rotation", "scale"], ["location (Vector or None) \u2013 The translation component.\n", "rotation (3x3 Matrix, Quaternion, Euler or None) \u2013 The rotation component.\n", "scale (Vector or None) \u2013 The scale component.\n"], "Returns\nCombined transformation matrix.\nReturn type\n4x4 Matrix\n# Compute local object transformation matrix:\nif obj.rotation_mode == 'QUATERNION':\n    matrix = mathutils.Matrix.LocRotScale(obj.location, obj.rotation_quaternion, obj.scale)\nelse:\n    matrix = mathutils.Matrix.LocRotScale(obj.location, obj.rotation_euler, obj.scale)\n"], "OrthoProjection()": ["Create a matrix to represent an orthographic projection.\n", ["axis", "size"], ["axis (string or Vector) \u2013 Can be any of the following: [\u2018X\u2019, \u2018Y\u2019, \u2018XY\u2019, \u2018XZ\u2019, \u2018YZ\u2019], where a single axis is for a 2D matrix. Or a vector for an arbitrary axis\n", "size (int) \u2013 The size of the projection matrix to construct [2, 4].\n"], "Returns\nA new projection matrix.\nReturn type\nMatrix\n"], "Rotation()": ["Create a matrix representing a rotation.\n", ["angle", "size", "axis"], ["angle (float) \u2013 The angle of rotation desired, in radians.\n", "size (int) \u2013 The size of the rotation matrix to construct [2, 4].\n", "axis (string or Vector) \u2013 a string in [\u2018X\u2019, \u2018Y\u2019, \u2018Z\u2019] or a 3D Vector Object (optional when size is 2).\n"], "Returns\nA new rotation matrix.\nReturn type\nMatrix\n"], "Scale()": ["Create a matrix representing a scaling.\n", ["factor", "size", "axis"], ["factor (float) \u2013 The factor of scaling to apply.\n", "size (int) \u2013 The size of the scale matrix to construct [2, 4].\n", "axis (Vector) \u2013 Direction to influence scale. (optional).\n"], "Returns\nA new scale matrix.\nReturn type\nMatrix\n"], "Shear()": ["Create a matrix to represent an shear transformation.\n", ["plane", "size", "factor"], ["plane (string) \u2013 Can be any of the following: [\u2018X\u2019, \u2018Y\u2019, \u2018XY\u2019, \u2018XZ\u2019, \u2018YZ\u2019], where a single axis is for a 2D matrix only.\n", "size (int) \u2013 The size of the shear matrix to construct [2, 4].\n", "factor (float or float pair) \u2013 The factor of shear to apply. For a 3 or 4 size matrix pass a pair of floats corresponding with the plane axis.\n"], "Returns\nA new shear matrix.\nReturn type\nMatrix\n"], "Translation()": ["Create a matrix representing a translation.\n", ["vector"], ["vector (Vector) \u2013 The translation vector.\n"], "Returns\nAn identity matrix with a translation.\nReturn type\nMatrix\n"], "adjugate()": ["Set the matrix to its adjugate.\nRaises\nValueError \u2013 if the matrix cannot be adjugate.\nSee also\nAdjugate matrix on Wikipedia.\n", [], [], "None"], "adjugated()": ["Return an adjugated copy of the matrix.\n", [], [], "Returns\nthe adjugated matrix.\nReturn type\nMatrix\nRaises\nValueError \u2013 if the matrix cannot be adjugated\n"], "copy()": ["Returns a copy of this matrix.\n", [], [], "Returns\nan instance of itself\nReturn type\nMatrix\n"], "decompose()": ["Return the translation, rotation, and scale components of this matrix.\n", [], [], "Returns\ntuple of translation, rotation, and scale\nReturn type\n(Vector, Quaternion, Vector)\n"], "determinant()": ["Return the determinant of a matrix.\n", [], [], "Returns\nReturn the determinant of a matrix.\nReturn type\nfloat\nSee also\nDeterminant on Wikipedia.\n"], "freeze()": ["Make this object immutable.\nAfter this the object can be hashed, used in dictionaries & sets.\n", [], [], "Returns\nAn instance of this object.\n"], "identity()": ["Set the matrix to the identity matrix.\nNote\nAn object with a location and rotation of zero, and a scale of one will have an identity matrix.\nSee also\nIdentity matrix on Wikipedia.\n", [], [], "None"], "invert()": ["Set the matrix to its inverse.\n", ["fallback"], ["fallback (Matrix) \u2013 Set the matrix to this value when the inverse cannot be calculated (instead of raising a ValueError exception).\n"], "None"], "invert_safe()": ["Set the matrix to its inverse, will never error. If degenerated (e.g. zero scale on an axis), add some epsilon to its diagonal, to get an invertible one. If tweaked matrix is still degenerated, set to the identity matrix instead.\nSee also\nInverse Matrix on Wikipedia.\n", [], [], "None"], "inverted()": ["Return an inverted copy of the matrix.\n", ["fallback"], ["fallback (any) \u2013 return this when the inverse can\u2019t be calculated (instead of raising a ValueError).\n"], "Returns\nthe inverted matrix or fallback when given.\nReturn type\nMatrix\n"], "inverted_safe()": ["Return an inverted copy of the matrix, will never error. If degenerated (e.g. zero scale on an axis), add some epsilon to its diagonal, to get an invertible one. If tweaked matrix is still degenerated, return the identity matrix instead.\n", [], [], "Returns\nthe inverted matrix.\nReturn type\nMatrix\n"], "lerp()": ["Returns the interpolation of two matrices. Uses polar decomposition, see \u201cMatrix Animation and Polar Decomposition\u201d, Shoemake and Duff, 1992.\n", ["other", "factor"], ["other (Matrix) \u2013 value to interpolate with.\n", "factor (float) \u2013 The interpolation value in [0.0, 1.0].\n"], "Returns\nThe interpolated matrix.\nReturn type\nMatrix\n"], "normalize()": ["Normalize each of the matrix columns.\n", [], [], "None"], "normalized()": ["Return a column normalized matrix\n", [], [], "Returns\na column normalized matrix\nReturn type\nMatrix\n"], "resize_4x4()": ["Resize the matrix to 4x4.\n", [], [], "None"], "rotate()": ["Rotates the matrix by another mathutils value.\n", ["other"], ["other (Euler, Quaternion or Matrix) \u2013 rotation component of mathutils value\n"], "None"], "to_2x2()": ["Return a 2x2 copy of this matrix.\n", [], [], "Returns\na new matrix.\nReturn type\nMatrix\n"], "to_3x3()": ["Return a 3x3 copy of this matrix.\n", [], [], "Returns\na new matrix.\nReturn type\nMatrix\n"], "to_4x4()": ["Return a 4x4 copy of this matrix.\n", [], [], "Returns\na new matrix.\nReturn type\nMatrix\n"], "to_euler()": ["Return an Euler representation of the rotation matrix (3x3 or 4x4 matrix only).\n", ["order", "euler_compat"], ["order (string) \u2013 Optional rotation order argument in [\u2018XYZ\u2019, \u2018XZY\u2019, \u2018YXZ\u2019, \u2018YZX\u2019, \u2018ZXY\u2019, \u2018ZYX\u2019].\n", "euler_compat (Euler) \u2013 Optional euler argument the new euler will be made compatible with (no axis flipping between them). Useful for converting a series of matrices to animation curves.\n"], "Returns\nEuler representation of the matrix.\nReturn type\nEuler\n"], "to_quaternion()": ["Return a quaternion representation of the rotation matrix.\n", [], [], "Returns\nQuaternion representation of the rotation matrix.\nReturn type\nQuaternion\n"], "to_scale()": ["Return the scale part of a 3x3 or 4x4 matrix.\n", [], [], "Returns\nReturn the scale of a matrix.\nReturn type\nVector\nNote\nThis method does not return a negative scale on any axis because it is not possible to obtain this data from the matrix alone.\n"], "to_translation()": ["Return the translation part of a 4 row matrix.\n", [], [], "Returns\nReturn the translation of a matrix.\nReturn type\nVector\n"], "transpose()": ["Set the matrix to its transpose.\nSee also\nTranspose on Wikipedia.\n", [], [], "None"], "transposed()": ["Return a new, transposed matrix.\n", [], [], "Returns\na transposed matrix\nReturn type\nMatrix\n"], "zero()": ["Set all the matrix values to zero.\nReturn type\nMatrix\n", [], [], "None"], "col": ["Access the matrix by columns, 3x3 and 4x4 only, (read-only).\n", [], [], "Type\nMatrix Access\n"], "is_frozen": ["True when this object has been frozen (read-only).\n", [], [], "Type\nboolean\n"], "is_identity": ["True if this is an identity matrix (read-only).\n", [], [], "Type\nbool\n"], "is_negative": ["True if this matrix results in a negative scale, 3x3 and 4x4 only, (read-only).\n", [], [], "Type\nbool\n"], "is_orthogonal": ["True if this matrix is orthogonal, 3x3 and 4x4 only, (read-only).\n", [], [], "Type\nbool\n"], "is_orthogonal_axis_vectors": ["True if this matrix has got orthogonal axis vectors, 3x3 and 4x4 only, (read-only).\n", [], [], "Type\nbool\n"], "is_valid": ["True when the owner of this data is valid.\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this object wraps external data (read-only).\n", [], [], "Type\nboolean\n"], "median_scale": ["The average scale applied to each axis (read-only).\n", [], [], "Type\nfloat\n"], "owner": ["The item this is wrapping or None (read-only).\n", [], [], "owner\uf0c1\nThe item this is wrapping or None (read-only).\n"], "row": ["Access the matrix by rows (default), (read-only).\n", [], [], "Type\nMatrix Access\n"], "translation": ["The translation component of the matrix.\n", [], [], "Type\nVector\n"]}], "Quaternion": ["This object gives access to Quaternions in Blender.\n", {"Quaternion()": ["This object gives access to Quaternions in Blender.\n", ["seq", "angle"], ["seq (Vector) \u2013 size 3 or 4\n", "angle (float) \u2013 rotation angle, in radians\n"], "None"], "conjugate()": ["Set the quaternion to its conjugate (negate x, y, z).\n", [], [], "None"], "conjugated()": ["Return a new conjugated quaternion.\n", [], [], "Returns\na new quaternion.\nReturn type\nQuaternion\n"], "copy()": ["Returns a copy of this quaternion.\n", [], [], "Returns\nA copy of the quaternion.\nReturn type\nQuaternion\nNote\nuse this to get a copy of a wrapped quaternion with no reference to the original data.\n"], "cross()": ["Return the cross product of this quaternion and another.\n", ["other"], ["other (Quaternion) \u2013 The other quaternion to perform the cross product with.\n"], "Returns\nThe cross product.\nReturn type\nQuaternion\n"], "dot()": ["Return the dot product of this quaternion and another.\n", ["other"], ["other (Quaternion) \u2013 The other quaternion to perform the dot product with.\n"], "Returns\nThe dot product.\nReturn type\nfloat\n"], "freeze()": ["Make this object immutable.\nAfter this the object can be hashed, used in dictionaries & sets.\n", [], [], "Returns\nAn instance of this object.\n"], "identity()": ["Set the quaternion to an identity quaternion.\nReturn type\nQuaternion\n", [], [], "None"], "invert()": ["Set the quaternion to its inverse.\n", [], [], "None"], "inverted()": ["Return a new, inverted quaternion.\n", [], [], "Returns\nthe inverted value.\nReturn type\nQuaternion\n"], "make_compatible()": ["Make this quaternion compatible with another, so interpolating between them works as intended.\n", ["other"], [], "None"], "negate()": ["Set the quaternion to its negative.\nReturn type\nQuaternion\n", [], [], "None"], "normalize()": ["Normalize the quaternion.\n", [], [], "None"], "normalized()": ["Return a new normalized quaternion.\n", [], [], "Returns\na normalized copy.\nReturn type\nQuaternion\n"], "rotate()": ["Rotates the quaternion by another mathutils value.\n", ["other"], ["other (Euler, Quaternion or Matrix) \u2013 rotation component of mathutils value\n"], "None"], "rotation_difference()": ["Returns a quaternion representing the rotational difference.\n", ["other"], ["other (Quaternion) \u2013 second quaternion.\n"], "Returns\nthe rotational difference between the two quat rotations.\nReturn type\nQuaternion\n"], "slerp()": ["Returns the interpolation of two quaternions.\n", ["other", "factor"], ["other (Quaternion) \u2013 value to interpolate with.\n", "factor (float) \u2013 The interpolation value in [0.0, 1.0].\n"], "Returns\nThe interpolated rotation.\nReturn type\nQuaternion\n"], "to_axis_angle()": ["Return the axis, angle representation of the quaternion.\n", [], [], "Returns\naxis, angle.\nReturn type\n(Vector, float) pair\n"], "to_euler()": ["Return Euler representation of the quaternion.\n", ["order", "euler_compat"], ["order (string) \u2013 Optional rotation order argument in [\u2018XYZ\u2019, \u2018XZY\u2019, \u2018YXZ\u2019, \u2018YZX\u2019, \u2018ZXY\u2019, \u2018ZYX\u2019].\n", "euler_compat (Euler) \u2013 Optional euler argument the new euler will be made compatible with (no axis flipping between them). Useful for converting a series of matrices to animation curves.\n"], "Returns\nEuler representation of the quaternion.\nReturn type\nEuler\n"], "to_exponential_map()": ["Return the exponential map representation of the quaternion.\nThis representation consist of the rotation axis multiplied by the rotation angle. Such a representation is useful for interpolation between multiple orientations.\n", [], [], "Returns\nexponential map.\nReturn type\nVector of size 3\nTo convert back to a quaternion, pass it to the Quaternion constructor.\n"], "to_matrix()": ["Return a matrix representation of the quaternion.\n", [], [], "Returns\nA 3x3 rotation matrix representation of the quaternion.\nReturn type\nMatrix\n"], "to_swing_twist()": ["Split the rotation into a swing quaternion with the specified axis fixed at zero, and the remaining twist rotation angle.\n", ["axis"], ["axis \u2013 twist axis as a string in [\u2018X\u2019, \u2018Y\u2019, \u2018Z\u2019]\n"], "Returns\nswing, twist angle.\nReturn type\n(Quaternion, float) pair\n"], "angle": ["Angle of the quaternion.\n", [], [], "Type\nfloat\n"], "axis": ["Quaternion axis as a vector.\n", [], [], "Type\nVector\n"], "is_frozen": ["True when this object has been frozen (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when the owner of this data is valid.\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this object wraps external data (read-only).\n", [], [], "Type\nboolean\n"], "magnitude": ["Size of the quaternion (read-only).\n", [], [], "Type\nfloat\n"], "owner": ["The item this is wrapping or None (read-only).\n", [], [], "owner\uf0c1\nThe item this is wrapping or None (read-only).\n"], "w": ["Quaternion axis value.\n", [], [], "Type\nfloat\n"], "x": ["Quaternion axis value.\n", [], [], "Type\nfloat\n"], "y": ["Quaternion axis value.\n", [], [], "Type\nfloat\n"], "z": ["Quaternion axis value.\n", [], [], "Type\nfloat\n"]}], "Vector": ["This object gives access to Vectors in Blender.\n", {"Vector()": ["This object gives access to Vectors in Blender.\n", ["seq"], ["seq (sequence of numbers) \u2013 Components of the vector, must be a sequence of at least two\n"], "None"], "Fill()": ["Create a vector of length size with all values set to fill.\n", ["size", "fill"], ["size (int) \u2013 The length of the vector to be created.\n", "fill (float) \u2013 The value used to fill the vector.\n"], "None"], "Linspace()": ["Create a vector of the specified size which is filled with linearly spaced values between start and stop values.\n", ["start", "stop", "size"], ["start (int) \u2013 The start of the range used to fill the vector.\n", "stop (int) \u2013 The end of the range used to fill the vector.\n", "size (int) \u2013 The size of the vector to be created.\n"], "None"], "Range()": ["Create a filled with a range of values.\n", ["start", "stop", "step"], ["start (int) \u2013 The start of the range used to fill the vector.\n", "stop (int) \u2013 The end of the range used to fill the vector.\n", "step (int) \u2013 The step between successive values in the vector.\n"], "None"], "Repeat()": ["Create a vector by repeating the values in vector until the required size is reached.\n", ["vector", "size"], ["None", "size (int) \u2013 The size of the vector to be created.\n"], "None"], "angle()": ["Return the angle between two vectors.\n", ["other", "fallback"], ["other (Vector) \u2013 another vector to compare the angle with\n", "fallback (any) \u2013 return this when the angle can\u2019t be calculated (zero length vector), (instead of raising a ValueError).\n"], "Returns\nangle in radians or fallback when given\nReturn type\nfloat\n"], "angle_signed()": ["Return the signed angle between two 2D vectors (clockwise is positive).\n", ["other", "fallback"], ["other (Vector) \u2013 another vector to compare the angle with\n", "fallback (any) \u2013 return this when the angle can\u2019t be calculated (zero length vector), (instead of raising a ValueError).\n"], "Returns\nangle in radians or fallback when given\nReturn type\nfloat\n"], "copy()": ["Returns a copy of this vector.\n", [], [], "Returns\nA copy of the vector.\nReturn type\nVector\nNote\nuse this to get a copy of a wrapped vector with no reference to the original data.\n"], "cross()": ["Return the cross product of this vector and another.\n", ["other"], ["other (Vector) \u2013 The other vector to perform the cross product with.\n"], "Returns\nThe cross product.\nReturn type\nVector or float when 2D vectors are used\nNote\nboth vectors must be 2D or 3D\n"], "dot()": ["Return the dot product of this vector and another.\n", ["other"], ["other (Vector) \u2013 The other vector to perform the dot product with.\n"], "Returns\nThe dot product.\nReturn type\nfloat\n"], "freeze()": ["Make this object immutable.\nAfter this the object can be hashed, used in dictionaries & sets.\n", [], [], "Returns\nAn instance of this object.\n"], "lerp()": ["Returns the interpolation of two vectors.\n", ["other", "factor"], ["other (Vector) \u2013 value to interpolate with.\n", "factor (float) \u2013 The interpolation value in [0.0, 1.0].\n"], "Returns\nThe interpolated vector.\nReturn type\nVector\n"], "negate()": ["Set all values to their negative.\n", [], [], "None"], "normalize()": ["Normalize the vector, making the length of the vector always 1.0.\nWarning\nNormalizing a vector where all values are zero has no effect.\nNote\nNormalize works for vectors of all sizes, however 4D Vectors w axis is left untouched.\n", [], [], "None"], "normalized()": ["Return a new, normalized vector.\n", [], [], "Returns\na normalized copy of the vector\nReturn type\nVector\n"], "orthogonal()": ["Return a perpendicular vector.\n", [], [], "Returns\na new vector 90 degrees from this vector.\nReturn type\nVector\nNote\nthe axis is undefined, only use when any orthogonal vector is acceptable.\n"], "project()": ["Return the projection of this vector onto the other.\n", ["other"], ["other (Vector) \u2013 second vector.\n"], "Returns\nthe parallel projection vector\nReturn type\nVector\n"], "reflect()": ["Return the reflection vector from the mirror argument.\n", ["mirror"], ["mirror (Vector) \u2013 This vector could be a normal from the reflecting surface.\n"], "Returns\nThe reflected vector matching the size of this vector.\nReturn type\nVector\n"], "resize()": ["Resize the vector to have size number of elements.\n", ["size"], [], "None"], "resize_2d()": ["Resize the vector to 2D (x, y).\n", [], [], "None"], "resize_3d()": ["Resize the vector to 3D (x, y, z).\n", [], [], "None"], "resize_4d()": ["Resize the vector to 4D (x, y, z, w).\n", [], [], "None"], "resized()": ["Return a resized copy of the vector with size number of elements.\n", ["size"], [], "Returns\na new vector\nReturn type\nVector\n"], "rotate()": ["Rotate the vector by a rotation value.\nNote\n2D vectors are a special case that can only be rotated by a 2x2 matrix.\n", ["other"], ["other (Euler, Quaternion or Matrix) \u2013 rotation component of mathutils value\n"], "None"], "rotation_difference()": ["Returns a quaternion representing the rotational difference between this vector and another.\n", ["other"], ["other (Vector) \u2013 second vector.\n"], "Returns\nthe rotational difference between the two vectors.\nReturn type\nQuaternion\nNote\n2D vectors raise an AttributeError.\n"], "slerp()": ["Returns the interpolation of two non-zero vectors (spherical coordinates).\n", ["other", "factor", "fallback"], ["other (Vector) \u2013 value to interpolate with.\n", "factor (float) \u2013 The interpolation value typically in [0.0, 1.0].\n", "fallback (any) \u2013 return this when the vector can\u2019t be calculated (zero length vector or direct opposites), (instead of raising a ValueError).\n"], "Returns\nThe interpolated vector.\nReturn type\nVector\n"], "to_2d()": ["Return a 2d copy of the vector.\n", [], [], "Returns\na new vector\nReturn type\nVector\n"], "to_3d()": ["Return a 3d copy of the vector.\n", [], [], "Returns\na new vector\nReturn type\nVector\n"], "to_4d()": ["Return a 4d copy of the vector.\n", [], [], "Returns\na new vector\nReturn type\nVector\n"], "to_track_quat()": ["Return a quaternion rotation from the vector and the track and up axis.\n", ["track", "up"], ["track (string) \u2013 Track axis in [\u2018X\u2019, \u2018Y\u2019, \u2018Z\u2019, \u2018-X\u2019, \u2018-Y\u2019, \u2018-Z\u2019].\n", "up (string) \u2013 Up axis in [\u2018X\u2019, \u2018Y\u2019, \u2018Z\u2019].\n"], "Returns\nrotation from the vector and the track and up axis.\nReturn type\nQuaternion\n"], "to_tuple()": ["Return this vector as a tuple with.\n", ["precision"], ["precision (int) \u2013 The number to round the value to in [-1, 21].\n"], "Returns\nthe values of the vector rounded by precision\nReturn type\ntuple\n"], "zero()": ["Set all values to zero.\n", [], [], "None"], "is_frozen": ["True when this object has been frozen (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when the owner of this data is valid.\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this object wraps external data (read-only).\n", [], [], "Type\nboolean\n"], "length": ["Vector Length.\n", [], [], "Type\nfloat\n"], "length_squared": ["Vector length squared (v.dot(v)).\n", [], [], "Type\nfloat\n"], "magnitude": ["Vector Length.\n", [], [], "Type\nfloat\n"], "owner": ["The item this is wrapping or None (read-only).", [], [], "owner\uf0c1\nThe item this is wrapping or None (read-only)."]}]}

types = []
for i,type in enumerate(dict_mathutils.keys()):
    types.append((type,type,dict_mathutils[type][0],i))

class SvMathutilsNode(SverchCustomTreeNode, bpy.types.Node):
    '''The most basic types of operators in mathutils, which are the cornerstone of mathutils'''
    bl_idname = 'SvMathutilsNode'
    bl_label = 'Mathutils'
    #bl_icon = 'OUTLINER_OB_EMPTY'
    sv_icon = 'SV_BM_MU'
    
    def updata_oper(self,context):
        for key in self.inputs.keys():
            self.safe_socket_remove('inputs',key)
        
        #对于特殊的类创建方法
        class_fun = ['Color()', 'Euler()', 'Matrix()', 'Quaternion()', 'Vector()']
        if self.oper not in class_fun:
            self.inputs.new('SvStringsSocket','input').description = 'Input element data'

        for i,p in enumerate(dict_mathutils[self.typ][1][self.oper][1]):
            pras = dict_mathutils[self.typ][1][self.oper][2]
            if pras:
                des = pras[i]
            else:
                des = 'None'
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs['return'].description = dict_mathutils[self.typ][1][self.oper][-1]
        updateNode(self,context)
    
    typ:EnumProperty(
        name='Types',
        description='Most basic type',
        items=types,
        update=updata_oper)

    def oper_enu(self,context):
        opers = []
        class_dict = dict_mathutils[self.typ][1]
        for i,o in enumerate(class_dict):
            opers.append((o,o,class_dict[o][0],i))
        return opers

    oper: EnumProperty(
        name='Operators',
        description = 'Operator of the most basic type(mathutils)',
        items= oper_enu,
        update=updata_oper)
    
    def draw_buttons(self, context, layout):
        layout.prop(self,'typ',text='')
        layout.prop(self,'oper',text='')

    def sv_init(self, context):
        for i,p in enumerate(dict_mathutils[self.typ][1][self.oper][1]):
            des = dict_mathutils[self.typ][1][self.oper][2][i]
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs.new('SvStringsSocket','return').description = dict_mathutils[self.typ][1][self.oper][-1]
        
    def process(self):
        input = []
        for p in self.inputs.keys():
            value = self.inputs[p].sv_get(default = [])
            input.append(value)
        input = match_long_repeat(input)

        if self.inputs[0].is_linked:
            return_ = self.proce(input)
        else:
            return_ = []
        self.outputs['return'].sv_set(return_)

    def proce(self,input):
        return_ = []
        class_fun = ['Color()', 'Euler()', 'Matrix()', 'Quaternion()', 'Vector()']
        for pars in zip(*input):
            result = []
            for p in zip(*pars):
                if self.oper in class_fun:
                    for i in range(len(p)):
                        name_p = dict_mathutils[self.typ][1][self.oper][1][i]
                        exec(name_p + '= p[i]')
                        if i == 0:
                            paramters = name_p
                        else:
                            paramters += ',' + name_p
                    fun = 'mathutils.' + self.oper[:-2]+'('+ paramters + ')'
                    result.append(eval(fun))
                else:
                    if len(p) == 1:
                        fun = 'p[0]' + '.' + self.oper
                    else:
                        for i in range(len(p)-1):
                            name_p = dict_mathutils[self.typ][1][self.oper][1][i]
                            exec(name_p + '= p[i+1]')
                            if i == 0:
                                paramters = name_p
                            else:
                                paramters += ',' + name_p
                        fun = 'p[0]' + '.' + self.oper[:-2] + '(' + paramters + ')'
                    result.append(eval(fun))
            return_.append(result)
        return return_

def register():
    bpy.utils.register_class(SvMathutilsNode)


def unregister():
    bpy.utils.unregister_class(SvMathutilsNode)